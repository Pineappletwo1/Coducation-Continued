import CustomerDetailVm from "../../src/domain/customer-detail-section/CustomerDetailVm";

const espana = {id:'ESP', descripcion: 'Espana'};
const companyName = 'AIDA';

const targetCustomer = { 
    isCompany: false, 
    name: 'alfredo', 
    firstSurname: 'casado', 
    secondSurname: 'bernardez', 
    taxId: '124', 
    address: 'joaquin lorenzo', 
    city: 'madrid', 
    state: 'madrid', 
    country: 'spain', 
    phoneNumber: '12435', 
    email: 'a@b.es', 
    birthDate: '01012000', 
    id: undefined, 
    disabled: false, 
    gender: 'M',
    postalCode: '123',
    company: companyName
};

describe("CustomerVm should", () => {

    const translator = aidaCore.TranslationService({});
    const customerCreated = { id: "customerId", company: companyName };
    const actionFactory = createActionFactoryMock({ customerCreated, customerReceived: targetCustomer, customersFound: [] });
    const newCustomerVm = CustomerDetailVm({actionFactory, newCustomerCallback: (customerFromBackend) => customerReceived = customerFromBackend, translator});
    let customerReceived;
    
    it("call backend and callback when creating a customer", () => {
        spyOn(actionFactory.customer,"createCustomer").and.callThrough();

        fill(newCustomerVm).with(targetCustomer);
        newCustomerVm.isEdition(false);
        newCustomerVm.saveCustomer();

        expect(actionFactory.customer.createCustomer).toHaveBeenCalledWith(targetCustomer, jasmine.any(Function));
        expect(customerReceived.id).toBe(customerCreated.id);
        expect(customerReceived.company).toBe(customerCreated.company);
    });

    it("call backend and callback when editing a customer", () => {
        const customerVm = CustomerDetailVm({actionFactory, customerEditedCallback: (customerFromBackend) => customerReceived = customerFromBackend, translator});
        spyOn(actionFactory.customer,"editCustomer").and.callThrough();

        fill(customerVm).with(targetCustomer);
        customerVm.isEdition(true);
        customerVm.saveCustomer();

        expect(actionFactory.customer.editCustomer).toHaveBeenCalledWith(targetCustomer, jasmine.any(Function));
        expect(customerReceived.id).toBe(customerCreated.id);
        expect(customerReceived.company).toBe(customerCreated.company);
    });

    it("show customers coincidences if necessary when creating a new customer", () => {
        const customerVm = CustomerDetailVm({actionFactory, newCustomerCallback: (customerFromBackend) => customerReceived = customerFromBackend, translator});
        spyOn(actionFactory.customer, "searchCustomersDescriptions"); 
        
        fill(customerVm).with(targetCustomer);
        customerVm.isEdition(false);
        customerVm.saveCustomer();

        expect(actionFactory.customer.searchCustomersDescriptions).toHaveBeenCalledWith({name: customerVm.name(), firstSurname: customerVm.firstSurname()}, jasmine.any(Function));
    });

    describe("validate", () => {
        it("customer is invalid when has not name", () => {
            const customer = CustomerDetailVm({translator});
            expect(customer.canSaveCustomer()).toBe(false);
        });

        it("customer is valid when has name", () => {
            const customer = CustomerDetailVm({translator});
            customer.name('anyName');
            expect(customer.canSaveCustomer()).toBe(true);
        });

        it("customer is valid if has an email and it is well formatted", () => {
            const customer = CustomerDetailVm({translator});
            customer.name('anyName');
            customer.email('a@a.com');
            expect(customer.canSaveCustomer()).toBe(true);
        });

        it("customer is invalid if has an email and it is bad formatted", () => {
            const customer = CustomerDetailVm({translator});
            customer.name('anyName');
            customer.email('a@');
            expect(customer.canSaveCustomer()).toBe(false);
        });
    });

    describe("show customer", () => {
        it("reset properties when call show without customerId", () => {
            const customer = CustomerDetailVm({actionFactory, translator});
            customer.name('someName');
            customer.company(companyName);
            customer.show();

            expect(customer.isShown()).toBe(true);
            expect(customer.name()).toBe(undefined);
            expect(customer.company()).toBe(undefined);
        });

        it("get customer from backend when call show with customerid", () => {
            const customer = CustomerDetailVm({actionFactory, translator});
            customer.show({customerId: 'anyId'});

            expect(customer.name()).toBe(targetCustomer.name);
            expect(customer.firstSurname()).toBe(targetCustomer.firstSurname);
            expect(customer.secondSurname()).toBe(targetCustomer.secondSurname);
            expect(customer.taxId()).toBe(targetCustomer.taxId);
            expect(customer.address()).toBe(targetCustomer.address);
            expect(customer.city()).toBe(targetCustomer.city);
            expect(customer.state()).toBe(targetCustomer.state);
            expect(customer.country()).toBe(targetCustomer.country);
            expect(customer.phoneNumber()).toBe(targetCustomer.phoneNumber);
            expect(customer.email()).toBe(targetCustomer.email);
            expect(customer.birthDate()).toBe(targetCustomer.birthDate);
            expect(customer.gender()).toBe(targetCustomer.gender);
            expect(customer.postalCode()).toBe(targetCustomer.postalCode);
            expect(customer.id()).toBe(targetCustomer.id);
            expect(customer.disabled()).toBe(targetCustomer.disabled);
            expect(customer.company()).toBe(targetCustomer.company);
        });
        
        it("countries are loaded when show customer", ()=>{
            const customer = CustomerDetailVm({actionFactory, translator});
            customer.show();
            
            expect(customer.availableCountries().length).toBe(1);
            expect(customer.availableCountries()[0].id).toBe(espana.id);
            expect(customer.availableCountries()[0].description).toBe(espana.description);
        });
    });

    describe("do not hide customer form", ()=>{
        it("after editing from customer detail view",() => {
            const customerVm = CustomerDetailVm({actionFactory, customerEditedCallback: (customerFromBackend) => customerReceived = customerFromBackend, translator, hideFormAfterSaving : false});

            fill(customerVm).with(targetCustomer);
            customerVm.show();
            customerVm.isEdition(true);
            customerVm.saveCustomer();

            expect(customerVm.isShown()).toBe(true);
        });
    });

    describe("detect coincidences", () => {
        it("show a selector with the customer if there is a customer with the same taxid", () => {
            const customersFound = [{ id: "customerId" }];
            const actionFactory = createActionFactoryMock({ customersFound });
            const customerVm = CustomerDetailVm({actionFactory, translator});
            customerVm.taxId("anyTaxId");

            customerVm.searchByTaxId();

            expect(customerVm.customerSelector.visible()).toBe(true);
            expect(customerVm.customerSelector.selectableCustomers()[0].customer).toBe(customersFound[0]);
        });

        it("not show a selector if there is not any customer with the same taxid", () => {
            const actionFactory = createActionFactoryMock({ customersFound: [] });
            const customerVm = CustomerDetailVm({actionFactory, translator});
            customerVm.taxId("anyTaxId");

            customerVm.searchByTaxId();

            expect(customerVm.customerSelector.visible()).toBe(false);
        });
        
        it("not call search when taxId is empty", () => {
            const actionFactory = createActionFactoryMock({ customersFound: [{ id: "customerId" }] });
            const customerVm = CustomerDetailVm({actionFactory, translator});
           
            customerVm.searchByTaxId();

            expect(actionFactory.isSearchCalled()).toBe(false);
        });

        it("show a selector with customers that match the name and surname", () => {
            const customersFound = [{ id: "customerId" }, { id: "customerAnotherId" }];
            const actionFactory = createActionFactoryMock({ customersFound });
            const customerVm = CustomerDetailVm({actionFactory, translator});
            customerVm.name("anyName");
            customerVm.firstSurname("anyFirstSurname");

            customerVm.searchLikeName();

            expect(customerVm.customerSelector.visible()).toBe(true);
            expect(customerVm.customerSelector.selectableCustomers()[0].customer).toBe(customersFound[0]);
            expect(customerVm.customerSelector.selectableCustomers()[1].customer).toBe(customersFound[1]);
        });

        it("not show a selector if there is not customer that matches name and surname", () => {
            const actionFactory = createActionFactoryMock({ customersFound: [] });
            spyOn(actionFactory.customer, "searchCustomersDescriptions");
            const customerVm = CustomerDetailVm({actionFactory, translator, newCustomerCallback: (customerFromBackend) => customerReceived = customerFromBackend});
            customerVm.name("anyName");
            customerVm.firstSurname("anyFirstSurname");

            customerVm.createCustomer();
            
            expect(actionFactory.customer.searchCustomersDescriptions).toHaveBeenCalled();
            expect(customerVm.customerSelector.visible()).toBe(false);
        });

        it("not call to search if name is undefined when trying to create a customer", () => {
            const actionFactory = createActionFactoryMock({ customersFound: [{ id: "customerId" }]});
            spyOn(actionFactory.customer, "searchCustomersDescriptions");
            const customerVm = CustomerDetailVm({actionFactory, translator, newCustomerCallback: (customerFromBackend) => customerReceived = customerFromBackend});
            customerVm.name();
            customerVm.firstSurname("anyFirstSurname");

            customerVm.createCustomer();

            expect(actionFactory.customer.searchCustomersDescriptions).not.toHaveBeenCalled();
        });

        it("not call to search if firstSurname is undefined", () => {
            const actionFactory = createActionFactoryMock({ customersFound: [{ id: "customerId" }] });
            spyOn(actionFactory.customer, "searchCustomersDescriptions");
            const customerVm = CustomerDetailVm({actionFactory,  translator,  newCustomerCallback: (customerFromBackend) => customerReceived = customerFromBackend});
            customerVm.name("anyName");
            customerVm.firstSurname();

            customerVm.createCustomer();

            expect(actionFactory.customer.searchCustomersDescriptions).not.toHaveBeenCalled();
        });
    });

    let customer = CustomerDetailVm({actionFactory, translator});

    describe("set isCompany", () => {
        ['true', 'false'].forEach((isCompanyValue)=>{
            it("as [${isCompanyValue}]", () => {
                
                customer.show();

                customer.setIsCompany(isCompanyValue);

                expect(customer.isCompany()).toBe(isCompanyValue); 
            });
        });
    });

    describe("check missing fields", () => {
              
        it("return true if user has set name", () => {
            customer.name(undefined);

            expect(customer.isNameMissing()).toBe(true);
        });
        
    });    
});

function createActionFactoryMock({customerCreated, customerReceived, customersFound}) {
    let isSearchCalled = false;
    return {
        customer: {
            createCustomer: (customer, callback) => {
                callback(customerCreated);
            },
            editCustomer: (customer, callback) => {
                callback(customerCreated);
            },
            getCustomer: (customer, callback) => callback(customerReceived),
            searchCustomersDescriptions: (filters, callback) => {
                isSearchCalled = true;
                callback(customersFound);
            },
            getAllCountries: (callback) => callback([espana])
        },
        isSearchCalled: () => isSearchCalled
    };
}


function fill(customerVm) {
    return {
        with(customer) {
            _.forOwn(customer, (value, key) => {
                const observable = customerVm[key];
                if (typeof(observable)==='function') {
                    observable(value);
                } else {
                    throw `not found observable ${key} in customerDetailVm`;
                }
            });
        }
    };
}