import template from './configurator-template';
import ModelCatalogSelectables from './scripts/modelCatalogSelectables';
import CatalogClient from '../../infrastructure/clients/catalogClient';
import ConfigurationClient from '../../infrastructure/clients/configurationClient';
import ModelConfiguration from './scripts/modelConfiguration';
import ConfiguratorApplier from './scripts/configuratorApplier';
import ConfiguratorNotifier from './scripts/configuratorNotifier';
import ColorConfigurator from './scripts/colorConfigurator';
import InteriorConfigurator from './scripts/interiorConfigurator';
import CombinationSelectorBindings from './scripts/combinationSelectorBindings';
import CombinationBuilder from './scripts/combinationsBuilder';

aidaCore.ComponentRegister('configurator', {
    script: (props, dependencyProvider) => {
        const selectedBrand = props.selectedBrand;
        const whenConfigurationChanged = props.whenConfigurationChanged;
        const loadedConfiguration = props.loadedConfiguration;

        const translator = dependencyProvider.getTranslator();
        const catalogClient = CatalogClient(dependencyProvider.getRestClient(), dependencyProvider.getErrorDialogPublisher(), {});
        const configurationClient = ConfigurationClient(dependencyProvider.getRestClient(), dependencyProvider.getErrorDialogPublisher(), {}, selectedBrand());
        const dialogPublisher = dependencyProvider.getDialogPublisher();

        return Configurator({ selectedBrand, whenConfigurationChanged, loadedConfiguration }, { translator, catalogClient, configurationClient, dialogPublisher });
    },
    template: template
});

export default function Configurator(
    { selectedBrand, whenConfigurationChanged, loadedConfiguration },
    { translator, catalogClient, configurationClient, dialogPublisher }) {

    let currentCatalog;
    const loadingCatalog = ko.observable(false);
    const selectedModel = ko.observable();
    const configuration = ModelConfiguration();
    const colorConfigurator = ColorConfigurator(whenColorIsSelected);
    const interiorConfigurator = InteriorConfigurator(whenInteriorIsSelected);
    const availableEquipments = ko.observableArray([]);
    const configuratorNotifier = ConfiguratorNotifier(dialogPublisher, translator);
    const combinationBuilder = CombinationBuilder(dialogPublisher, translator);
    const configuratorApplier = ConfiguratorApplier(configuratorNotifier, combinationBuilder, whenConfigurationIsApplied);
    const combinationSelectorBindings = CombinationSelectorBindings(dialogPublisher, translator);
    const loadedModel = ko.observable();
    let loadedConfigurationChanged = false;

    loadedConfiguration.subscribe(loadConfiguration);

    function whenConfigurationIsApplied(newConfiguration) {
        whenConfigurationChanged(newConfiguration.toJson());
        interiorConfigurator.setOptionsForSelectedColor(newConfiguration, currentCatalog);
        colorConfigurator.setOptionsForSelectedInterior(newConfiguration, currentCatalog);
        whenModelLoaded();
    }

    function whenModelLoaded() {
        if (!loadedConfigurationChanged) return;

        setColorForConfiguration(loadedConfiguration().color);
        setInteriorForConfiguration(loadedConfiguration().interior);
        setEquipmentForConfiguration(loadedConfiguration().equipments);
        loadedConfigurationChanged = false;
        whenConfigurationChanged(configuration.toJson());
    }

    // load configuration without call to server to avoid validate the configuration rules.
    function loadConfiguration(newConfiguration) {
        configuration.clean();
        loadedConfigurationChanged = true;
        loadedModel(newConfiguration.modelKey);
    }

    function setColorForConfiguration(color) {
        const colorToLoad = _(currentCatalog.colors).find(x => x.code == color.code);
        configuration.setColor(colorToLoad);
        colorConfigurator.selected(colorToLoad);
    }

    function setInteriorForConfiguration(interior) {
        const interiorToLoad = _(currentCatalog.interiors).find(x => x.code == interior.code);
        configuration.setInterior(interiorToLoad);
        interiorConfigurator.selected(interiorToLoad);
    }

    function setEquipmentForConfiguration(equipment) {
        const equipmentToLoad = getAllCatalogEquipmentForConfiguration(equipment);
        configuration.equipments(equipmentToLoad);
        selectAllEquipment(equipmentToLoad);
    }

    function getAllCatalogEquipmentForConfiguration(allLoadedConfigurationEquipment) {
        const allCatalogEquipments = _(currentCatalog.equipments.concat(currentCatalog.packages)).value();
        return _(allCatalogEquipments)
            .filter((x) => _(allLoadedConfigurationEquipment).any((e) => x.code == e.code))
            .value();
    }

    function selectAllEquipment(equipmentToLoad) {
        _(equipmentToLoad)
            .forEach(equipment => equipment.selected(true))
            .value();
    }

    function whenModelCategorySelected(categoryId) {
        configuration.clean();
        configuration.setModelGroupCode(getModelGroupCodeFrom(categoryId));
        whenConfigurationChanged(configuration.toJson());
    }

    function getModelGroupCodeFrom(categoryId) {
        return categoryId.substring(0, categoryId.indexOf("_"));
    }

    function whenModelCategoryUnselected() {
        configuration.clean();
        selectedModel(undefined);
        whenConfigurationChanged(configuration.toJson());
        cleanCatalog();
    }

    function whenModelSelected(model) {
        configuration.setModel(model);
        loadingCatalog(true);
        catalogClient.getCatalog(selectedBrand().id, configuration.modelId(), whenCatalogReceived, onCatalogError);
    }

    function whenModelUnselected() {
        configuration.removeModel();
        selectedModel(undefined);
        whenConfigurationChanged(configuration.toJson());
        cleanCatalog();
    }

    function cleanCatalog() {
        if (_.isObject(currentCatalog)) {
            currentCatalog.clean();
            initializeSelectors();
        }
    }

    function whenCatalogReceived(catalogJson) {
        loadingCatalog(false);
        currentCatalog = ModelCatalogSelectables(configuration.modelId(), configuration.modelDescription(), catalogJson);
        initializeSelectors();
        let model = currentCatalog.getModel();
        if (model.compulsoryCombinations && model.compulsoryCombinations.length > 1) {
            combinationSelectorBindings.updateToShowAsMandatory(model.code, model.compulsoryCombinations, currentCatalog, whenModelCombinationIsSelected);
        } else {
            configurationClient.createConfiguration(selectedBrand().id, model, whenConfigurationApplied, onConfigurationError);
        }
    }

    function onCatalogError() {
        loadingCatalog(false);
    }

    function onConfigurationError() {
        selectedModel(undefined);
    }

    function whenColorIsSelected(color) {
        if (configuration.isEmpty() || loadedConfigurationChanged) return;

        if (color && color.hasForcedCombinations) {
            combinationSelectorBindings.updateToShow(color.code, color.compulsoryCombinations, currentCatalog, whenColorCombinationSelected);
            return;
        }
        if (color) {
            configurationClient.changeColorWithoutCombination(configuration, color.code, whenConfigurationApplied, restoreConfiguredColor);
        } else {
            configurationClient.removeColor(configuration, whenConfigurationApplied);
        }
    }

    function whenInteriorIsSelected(interior) {
        if (configuration.isEmpty() || loadedConfigurationChanged) return;

        if (_.isObject(interior) && interior.hasForcedCombinations) {
            combinationSelectorBindings.updateToShow(interior.code, interior.compulsoryCombinations, currentCatalog, whenInteriorCombinationSelected);
            return;
        }
        if (_.isObject(interior)) {
            configurationClient.changeInteriorWithoutCombination(configuration, interior.code, whenConfigurationApplied, restoreConfiguredInterior);
        } else {
            configurationClient.removeInterior(configuration, whenConfigurationApplied);
        }
    }

    function whenEquipmentSelected(equipment) {
        if (equipment.hasForcedCombinations) {
            combinationSelectorBindings.updateToShow(equipment.code, equipment.compulsoryCombinations, currentCatalog, whenEquipmentWithCombinationSelected);
            return;
        }
        if (equipment.isPackage()) {
            configurationClient.addPackageWithoutCombination(configuration, equipment.code, whenConfigurationApplied);
        } else {
            configurationClient.addEquipmentWithoutCombination(configuration, equipment.code, whenConfigurationApplied);
        }
    }

    function whenEquipmentUnselected(equipment) {
        if (equipment.isPackage()) {
            configurationClient.removePackage(configuration, equipment.code, whenConfigurationApplied);
        } else {
            configurationClient.removeEquipment(configuration, equipment.code, whenConfigurationApplied);
        }
    }

    function initializeSelectors() {
        colorConfigurator.initializeSelector(currentCatalog.colors);
        interiorConfigurator.initializeSelector(currentCatalog.interiors);
        availableEquipments(currentCatalog.packages.concat(currentCatalog.equipments));
    }

    function whenModelCombinationIsSelected(selectedCombination) {
        configurationClient.createConfigurationWithCombination(selectedBrand().id, selectedCombination, whenConfigurationApplied, onConfigurationError);
    }

    function whenColorCombinationSelected(selectedCombination) {
        if (_.isObject(selectedCombination)) {
            configurationClient.changeColor(configuration, selectedCombination, whenConfigurationApplied, restoreConfiguredColor);
            return;
        }
        restoreConfiguredColor();
    }

    function whenInteriorCombinationSelected(selectedCombination) {
        if (_.isObject(selectedCombination)) {
            configurationClient.changeInterior(configuration, selectedCombination, whenConfigurationApplied, restoreConfiguredInterior);
            return;
        }
        restoreConfiguredInterior();
    }

    function whenEquipmentWithCombinationSelected(selectedCombination) {
        if (!_.isObject(selectedCombination)) return;

        if (selectedCombination.root.isPackage()) {
            configurationClient.addPackage(configuration, selectedCombination, whenConfigurationApplied);
        } else {
            configurationClient.addEquipment(configuration, selectedCombination, whenConfigurationApplied);
        }
    }

    function whenConfigurationApplied(newConfiguration, actionType) {
        configuratorApplier.applyConfiguration(configuration, newConfiguration, actionType, currentCatalog);
    }

    function restoreConfiguredColor() {
        colorConfigurator.selected(configuration.configuredColor());
    }

    function restoreConfiguredInterior() {
        interiorConfigurator.selected(configuration.configuredInterior());
    }

    function getLabels() {
        return {
            title: translator.translate('SharedDomain.Filters')
        };
    }

    return {
        labels: getLabels(),
        selectedBrand,
        selectedModel,
        colorOptions: colorConfigurator.options,
        selectedColor: colorConfigurator.selected,
        interiorOptions: interiorConfigurator.options,
        selectedInterior: interiorConfigurator.selected,
        availableEquipments,
        whenModelSelected,
        whenModelUnselected,
        whenModelCategorySelected,
        whenModelCategoryUnselected,
        whenEquipmentSelected,
        whenEquipmentUnselected,
        combinationSelectorVisible: combinationSelectorBindings.combinationSelectorVisible,
        isCombinationMandatory: combinationSelectorBindings.isCombinationMandatory,
        combinationOptions: combinationSelectorBindings.combinationOptions,
        whenCombinationSelected: combinationSelectorBindings.whenSelected,
        selectedEquipment: configuration.equipments,
        loadingCatalog,
        loadedModel
    };
}