import CombinationSelector from '../../src/domain/combination-selector/combination-selector';
import Combination from '../../src/domain/configurator/scripts/combination';

describe('combination-selector should', () => {

    const whenSelected = () => { };
    const translator = aidaCore.TranslationService({});

    function aCombination(items) {
        const root = { selected: ko.observable(false) };
        const combinationItems = _.map(items, (itemDescription) => {
            return {
                description: itemDescription,
                isInCatalog: () => true
            };
        });

        return Combination(root, combinationItems, {}, { error: () => { } }, translator);
    }

    const isSelectionMandatory = ko.observable(false);
    const options = ko.observableArray([]);

    it('show available compulsory options when it is visible', () => {
        const visible = ko.observable(false);
        const combinationSelector = CombinationSelector({ visible, isSelectionMandatory, options, translator, whenSelected });
        options([aCombination(["item1", "item2"])]);

        visible(true);

        expect(combinationSelector.choices().length).toEqual(1);
        expect(combinationSelector.choices()[0].items.length).toEqual(2);
        expect(combinationSelector.choices()[0].items[0].description).toEqual("item1");
        expect(combinationSelector.choices()[0].items[1].description).toEqual("item2");
    });

    it('reset options when uses it twice', () => {
        const visible = ko.observable(false);
        const combinationSelector = CombinationSelector({ visible, isSelectionMandatory, options, translator, whenSelected });
        options([aCombination(["item1", "item2"])]);
        visible(true);
        combinationSelector.visible(false);
        options([aCombination(["item3"])]);

        visible(true);

        expect(combinationSelector.choices().length).toEqual(1);
        expect(combinationSelector.choices()[0].items.length).toEqual(1);
        expect(combinationSelector.choices()[0].items[0].description).toEqual("item3");
    });

    it('call whenSelected callback when a combination is selected', () => {

        let selectedCombination = undefined;
        const whenSelected = (selected) => { 
            selectedCombination = selected; 
        };

        const visible = ko.observable(false);
        const combinationSelector = CombinationSelector({ visible, isSelectionMandatory, options, translator, whenSelected });
        options([aCombination(["item1", "item2"]), aCombination(["item3"])]);
        visible(true);

        combinationSelector.choices()[0].select();

        expect(selectedCombination).toBe(combinationSelector.choices()[0]);
        expect(combinationSelector.visible()).toBe(false);
    });

    it('select no combination when is closed', () => {
        let selectedCombination = undefined;
        const whenSelected = (selected) => { 
            selectedCombination = selected; 
        };
        const visible = ko.observable(false);
        const combinationSelector = CombinationSelector({ visible, isSelectionMandatory, options, translator, whenSelected });
        options([aCombination(["item1", "item2"]), aCombination(["item3"])]);
        visible(true);

        combinationSelector.visible(false);

        expect(selectedCombination).toBe(undefined);
    });
});