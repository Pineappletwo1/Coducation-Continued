export default function ConfiguratorApplier(configuratorNotifier, combinationBuilder, whenConfigurationChanged) {

    const EmptyInterior = undefined;

    function applyConfiguration(modelConfiguration, newConfiguration, actionType, selectableCatalog) {
        let newAutofixes = _.filter(newConfiguration.autoFixes, (x) => x.isNewAutofix);
        if (newAutofixes.length > 0) {
            configuratorNotifier.notifyAutofixesConfirmation(
                newAutofixes,
                () => continueApply(modelConfiguration, newConfiguration, actionType, selectableCatalog)
            );
        } else {
            continueApply(modelConfiguration, newConfiguration, actionType, selectableCatalog);
        }
    }

    function continueApply(modelConfiguration, newConfiguration, actionType, selectableCatalog) {
        configuratorNotifier.notifyChangesInConfiguration(modelConfiguration, newConfiguration, actionType);
        commitApply(modelConfiguration, newConfiguration, selectableCatalog);
    }

    function commitApply(modelConfiguration, newConfiguration, selectableCatalog) {
        clearAllSelections(modelConfiguration, selectableCatalog);

        modelConfiguration.setAutofixes(newConfiguration.autoFixes);

        applyModelCompulsory(modelConfiguration, newConfiguration, selectableCatalog);
        applyEquipmentsAndPackages(modelConfiguration, newConfiguration, selectableCatalog);
        applyColor(modelConfiguration, newConfiguration, selectableCatalog);
        applyInterior(modelConfiguration, newConfiguration, selectableCatalog);
        whenConfigurationChanged(modelConfiguration);
    }

    function clearAllSelections(modelConfiguration, selectableCatalog) {
        modelConfiguration.cleanSelections();
        selectableCatalog.unselectAll();
    }

    function applyModelCompulsory(modelConfiguration, newConfiguration, selectableCatalog) {
        if (!newConfiguration.modelCompulsory || !newConfiguration.modelCompulsory.combinedItems) return;

        _.each(newConfiguration.modelCompulsory.combinedItems, (x) => {
            let item = selectableCatalog.findItem(x.code);
            item.selected(true);
            modelConfiguration.addCompulsory(item);
        });
    }

    function applyEquipmentsAndPackages(modelConfiguration, newConfiguration, selectableCatalog) {
        const equipmentsAndPackages = _(newConfiguration.equipments).concat(newConfiguration.packages).value();
        _.each(equipmentsAndPackages, (x) => {
            let item = selectableCatalog.findItem(x.code);
            item.selected(true);
            applyCombination(item, x.combination, selectableCatalog);
            modelConfiguration.addEquipment(item);
        });
    }

    function applyColor(modelConfiguration, newConfiguration, selectableCatalog) {
        let colorSelectable = undefined;
        if (_.isObject(newConfiguration.color)) {
            colorSelectable = selectableCatalog.findItem(newConfiguration.color.code);
            applyCombination(colorSelectable, newConfiguration.color.combination, selectableCatalog);
        }
        modelConfiguration.setColor(colorSelectable);
    }

    function applyCombination(catalogItem, combinationToApply, selectableCatalog) {
        if (combinationToApply && combinationToApply.length > 0) {
            const combination = combinationBuilder.buildCombinationFor(catalogItem, combinationToApply, selectableCatalog);
            combination.selectItems();
            catalogItem.setCombination(combination);
        }
    }

    function applyInterior(modelConfiguration, newConfiguration, selectableCatalog) {
        let interiorSelectable = EmptyInterior;
        if (_.isObject(newConfiguration.interior)) {
            interiorSelectable = selectableCatalog.findItem(newConfiguration.interior.code);
            applyCombination(interiorSelectable, newConfiguration.interior.combination, selectableCatalog);
        }
        modelConfiguration.setInterior(interiorSelectable);
    }

    return {
        applyConfiguration,
        continueApply
    };
}