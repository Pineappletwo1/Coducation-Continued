import Configurator from "../../src/domain/configurator/configurator";

describe("configurator when configuration has autofixes should", () => {
    const translator = aidaCore.TranslationService({
        "Configurator.ApplyConfiguration.Message": "{0} {1}"
    });

    let configurationClient;
    let airConditioner;
    let rim;
    let radio;
    let roof;
    let modelConfiguration = {};

    beforeEach(() => {
        airConditioner = { code: 'airConditioner', isPackage: () => false };
        rim = { code: 'rim', isPackage: () => false };
        radio = { code: 'radio', isPackage: () => false };
        roof = { code: 'roof', isPackage: () => false };
        configurationClient = {};
        modelConfiguration = { equipments: [] };
    });

    it("ask the user to confirm apply configuration", () => {
        givenAConfiguration()
            .withNewAutofix({ newItem: rim, oldItem: airConditioner })
            .withNewAutofix({ newItem: roof, oldItem: radio })
            .build();
        const dialogPublisher = { confirmation: () => { } };
        spyOn(dialogPublisher, 'confirmation');
        let configurator = aConfiguratorWith({ dialogPublisher });

        configurator.whenEquipmentSelected(rim);

        expect(dialogPublisher.confirmation)
            .toHaveBeenCalledWith({ title: jasmine.any(String), message: jasmine.stringMatching(rim.code), callback: jasmine.any(Function) });
        expect(dialogPublisher.confirmation)
            .toHaveBeenCalledWith({ title: jasmine.any(String), message: jasmine.stringMatching(airConditioner.code), callback: jasmine.any(Function) });
        expect(dialogPublisher.confirmation)
            .toHaveBeenCalledWith({ title: jasmine.any(String), message: jasmine.stringMatching(roof.code), callback: jasmine.any(Function) });
        expect(dialogPublisher.confirmation)
            .toHaveBeenCalledWith({ title: jasmine.any(String), message: jasmine.stringMatching(radio.code), callback: jasmine.any(Function) });
    });

    it("not notify when autofixes are old", () => {
        givenAConfiguration()
            .withOldAutofix({ oldItem: airConditioner, newItem: rim })
            .build();
        const dialogPublisher = { confirmation: () => { } };
        spyOn(dialogPublisher, 'confirmation');
        let configurator = aConfiguratorWith({
            dialogPublisher: dialogPublisher,
            catalogClient: clientThatReturnsACatalog(airConditioner, rim)
        });

        configurator.whenModelSelected({
            key: { id: "123" },
            description: "VW Polo 1.2 Diesel"
        });

        expect(dialogPublisher.confirmation).not.toHaveBeenCalled();
    });

    function whenConfigurationChanged(newConfiguration) {
        modelConfiguration = newConfiguration;
    }

    it("apply configuration when the user accept autofixes", () => {
        givenAConfiguration()
            .withNewAutofix({ oldItem: airConditioner, newItem: rim })
            .withEquipment(rim)
            .build();
        const dialogPublisher = { confirmation: ({ callback }) => callback() };
        const configurator = aConfiguratorWith({
            dialogPublisher,
            whenConfigurationChanged,
            catalogClient: clientThatReturnsACatalog(airConditioner, rim)
        });

        configurator.whenModelSelected({
            key: { id: "123" },
            description: "VW Polo 1.2 Diesel"
        });

        expect(modelConfiguration.equipments.length).toBe(1);
        expect(modelConfiguration.equipments[0].code).toBe(rim.code);
    });

    it("not apply configuration when the user does not accept autofixes", () => {
        givenAConfiguration()
            .withNewAutofix({ oldItem: airConditioner, newItem: rim })
            .withEquipment(rim)
            .build();
        const dialogPublisher = { confirmation: () => { } };
        const configurator = aConfiguratorWith({
            dialogPublisher,
            whenConfigurationChanged,
            catalogClient: clientThatReturnsACatalog(airConditioner, rim)
        });

        configurator.whenModelSelected({
            key: { id: "123" },
            description: "VW Polo 1.2 Diesel"
        });

        expect(modelConfiguration.equipments.length).toBe(0);
    });

    function givenAConfiguration() {
        const autofixes = [];
        const equipments = [];
        const addAutofix = (autofix, isNew) => {
            autofixes.push({
                isNewAutofix: isNew,
                removedItem: autofix.oldItem.code,
                addedItem: autofix.newItem.code
            });
        };

        const self = {
            withNewAutofix(autofix) {
                addAutofix(autofix, true);
                return self;
            },
            withOldAutofix(autofix) {
                addAutofix(autofix, false);
                return self;
            },
            withEquipment(equipment) {
                equipments.push(equipment);
                return self;
            },
            build() {
                const newConfiguration = {
                    autoFixes: autofixes,
                    equipments: equipments,
                    packages: []
                };
                configurationClient.addEquipmentWithoutCombination =
                    (configuration, equipmentCode, callback) => callback(newConfiguration);
                configurationClient.createConfiguration = (brandId, model, callback) => callback(newConfiguration);
            }
        };
        return self;
    }

    function clientThatReturnsACatalog() {
        return {
            getCatalog: (brandId, model, callback) => { callback({ equipments: [airConditioner, rim] }); }
        };
    }

    function aConfiguratorWith({ dialogPublisher, catalogClient, whenConfigurationChanged }) {
        const selectedBrand = ko.observable({ id: '' });
        const loadedConfiguration = ko.observable();
        
        return Configurator(
            {
                selectedBrand,
                whenConfigurationChanged: whenConfigurationChanged || (() => { }),
                loadedConfiguration
            }, {
                configurationClient,
                dialogPublisher,
                translator,
                catalogClient
            });
    }
});