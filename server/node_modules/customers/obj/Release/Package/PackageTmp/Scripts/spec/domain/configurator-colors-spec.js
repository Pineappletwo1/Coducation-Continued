import Configurator from "../../src/domain/configurator/configurator";
import Combination from '../../src/domain/configurator/scripts/combination';
import CatalogHelper from './catalogHelper';

describe("configurator with color should", () => {

    const emptyColor = null;
    const catalog = CatalogHelper.catalog;
    const red = CatalogHelper.red;
    const black = CatalogHelper.black;
    const camera = CatalogHelper.camera;
    const bluetooth = CatalogHelper.bluetooth;

    let changeColorWithoutCombinationCall = {};

    const actionType = {
        IsChangeColor: () => { return false; }
    };
    const changeColorRequest = {};

    function createNewConfig() {
        return { color: null, interior: null, equipments: [], packages: [] };
    }

    function createConfigurationClient() {
        return {
            createConfiguration() { },
            changeColorWithoutCombination(modelConfiguration, colorCode, callback) {
                changeColorWithoutCombinationCall.modelConfiguration = modelConfiguration;
                changeColorWithoutCombinationCall.colorCode = colorCode;
                let newConfig = createNewConfig();
                newConfig.color = { code: colorCode };
                callback(newConfig, actionType);
            },
            changeColor(configuration, combination, callback) {
                changeColorRequest.combination = combination;
                let newConfig = createNewConfig();
                newConfig.color = { combination: _.map(combination.items, (item) => { return { code: item.description }; }) };
                callback(newConfig);
            },
            removeColor(configuration, callback) {
                let newConfig = createNewConfig();
                newConfig.color = null;
                callback(newConfig, actionType);
            }
        };
    }

    const catalogClient = {
        getCatalog(brandId, modelCode, callback) {
            callback(catalog);
        }
    };

    const translator = aidaCore.TranslationService({});
    const dialogPublisher = aidaCore.DialogPublisher;
    let modelConfiguration;
    const whenConfigurationChanged = (newConfiguration) => {
        modelConfiguration = newConfiguration;
    };
    let configurator;
    let configurationClient;

    const selectedBrand = ko.observable('V');
    const loadedConfiguration = ko.observable();

    beforeEach(() => {
        configurationClient = createConfigurationClient();
        configurator = Configurator(
            {
                selectedBrand,
                whenConfigurationChanged,
                loadedConfiguration
            }, {
                translator,
                catalogClient,
                configurationClient,
                dialogPublisher
            });
        catalog.modelCompulsoryCombinationChoices = [];
        modelConfiguration = {};
        configurator.combinationOptions([]);
    });

    describe("when selecting color", function () {
        actionType.IsChangeColor = () => { return true; };

        it("load available colors when a model is selected", function () {
            GivenASelectedModelFor(configurator);

            expect(configurator.colorOptions().length).toBe(3);
            expect(configurator.colorOptions()[0].code).toBe(red.code);
            expect(configurator.colorOptions()[0].description).toBe("X1X1 - red");
        });

        it("load allowed interiors for that color", function () {
            GivenASelectedModelFor(configurator);

            configurator.selectedColor(red);

            expect(configurator.interiorOptions().length).toBe(1);
            expect(configurator.interiorOptions()[0].code).toBe(CatalogHelper.leather.code);
            expect(configurator.interiorOptions()[0].description).toBe("A1 - cuero");
        });

        it("call backend when a color is selected", function () {
            changeColorWithoutCombinationCall = {};
            GivenASelectedModelFor(configurator);

            configurator.selectedColor(red);

            expect(changeColorWithoutCombinationCall.colorCode).toBe(red.code);
            expect(changeColorWithoutCombinationCall.modelConfiguration).not.toBe(null);
        });

        it("not call backend when a color is selected and the model is unselected", function () {
            spyOn(configurationClient, 'removeColor');
            GivenASelectedModelFor(configurator);
            configurator.selectedColor(red);

            configurator.whenModelUnselected();

            expect(configurationClient.removeColor).not.toHaveBeenCalled();
        });

        it("set the color to the configuration", () => {
            GivenASelectedModelFor(configurator);

            configurator.selectedColor(red);

            expect(modelConfiguration.color.code).toBe(red.code);
        });

        it("call backend when a color is unselected", function () {
            GivenASelectedModelFor(configurator);
            spyOn(configurationClient, "removeColor");

            configurator.selectedColor(emptyColor);

            expect(configurationClient.removeColor).toHaveBeenCalled();
        });

        it("remove the color to the configuration", () => {
            GivenASelectedModelFor(configurator);
            configurator.selectedColor(red);

            configurator.selectedColor(emptyColor);

            expect(modelConfiguration.color).toEqual({});
        });
    });

    describe('when color has compulsories', () => {

        beforeEach(() => {
            CatalogHelper.black.hasForcedCombinations = true;
            CatalogHelper.black.compulsoryCombinations = [[camera], [bluetooth]];
        });

        it("show selector when color has more than one compulsory", () => {
            GivenASelectedModelFor(configurator);

            configurator.selectedColor(black);

            expect(configurator.combinationSelectorVisible()).toBe(true);
            expect(configurator.isCombinationMandatory()).toBe(false);
            expect(configurator.combinationOptions().length).toBe(2);
            expect(configurator.combinationOptions()[0].items.length).toBe(1);
            expect(configurator.combinationOptions()[0].items[0].code).toBe("PR1");
            expect(configurator.combinationOptions()[1].items.length).toBe(1);
            expect(configurator.combinationOptions()[1].items[0].code).toBe("PR2");
        });

        it("call backend if a compulsory option is chosen", () => {
            GivenASelectedModelFor(configurator);
            configurator.selectedColor(black);
            const chosenCombination = aCombination([camera.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(changeColorRequest.combination).toEqual(chosenCombination);
        });

        it("apply configuration after calling the backend for a compulsory option", () => {
            GivenASelectedModelFor(configurator);
            configurator.selectedColor(black);
            const chosenCombination = aCombination([camera.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(modelConfiguration.color.combination[0].code).toEqual(camera.code);
        });

        it("restore previous color if backend fails", () => {
            configurationClient.changeColor = (configuration, combination, callback, errorCallback) => {
                errorCallback();
            };
            GivenASelectedModelFor(configurator);
            configurator.selectedColor(red);
            configurator.selectedColor(black);
            const chosenCombination = aCombination([camera.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(configurator.selectedColor().code).toEqual(red.code);
        });

        it("restore previous color if no combination is selected", () => {
            GivenASelectedModelFor(configurator);
            configurator.selectedColor(red);
            configurator.selectedColor(black);

            configurator.whenCombinationSelected(undefined);

            expect(configurator.selectedColor().code).toEqual(red.code);
        });
    });

    function aCombination(items) {
        const root = { selected: ko.observable(false) };
        const combinationItems = _.map(items, (itemDescription) => {
            return {
                description: itemDescription,
                isInCatalog: () => true
            };
        });

        return Combination(root, combinationItems, {}, { error: () => { } }, translator);
    }

    function GivenASelectedModelFor(configurator) {
        configurator.whenModelSelected({
            key: { id: "123" },
            description: "VW Polo 1.2 Diesel"
        });
    }
});