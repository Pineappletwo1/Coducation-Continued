import Configurator from "../../src/domain/configurator/configurator";
import CatalogHelper from './catalogHelper';
import Combination from '../../src/domain/configurator/scripts/combination';
import SelectableItem from "../../src/domain/configurator/scripts/selectableItem";

describe("configurator with equipments should", () => {

    const catalog = CatalogHelper.catalog;
    const camera = CatalogHelper.camera;
    const bluetooth = CatalogHelper.bluetooth;
    const safetyPackage = CatalogHelper.safetyPackage;
    const navigationPack = CatalogHelper.navigationPack;

    const actionType = {
        IsChangeEquipments: () => true
    };

    function createNewConfig() {
        return { color: null, interior: null, equipments: [], packages: [] };
    }

    function createConfigurationClient() {
        return {
            createConfiguration() { },
            addEquipmentWithoutCombination(modelConfiguration, equipmentCode, callback) {
                let newConfig = createNewConfig();
                newConfig.equipments = [{ code: equipmentCode }];
                callback(newConfig, actionType);
            },
            addEquipment(modelConfiguration, combination, callback) {
                let newConfig = createNewConfig();
                newConfig.equipments = [{
                    code: combination.root.code,
                    combination: _.map(combination.items, (item) => { return { code: item.description }; })
                }];
                callback(newConfig);
            },
            addPackageWithoutCombination(modelConfiguration, packageCode, callback) {
                let newConfig = createNewConfig();
                newConfig.packages = [{ code: packageCode }];
                callback(newConfig, actionType);
            },
            addPackage(modelConfiguration, combination, callback) {
                let newConfig = createNewConfig();
                newConfig.packages = [{
                    code: combination.root.code,
                    combination: _.map(combination.items, (item) => { return { code: item.description }; })
                }];
                callback(newConfig);
            },
            removeEquipment(modelConfiguration, equipmentCode, callback) {
                let newConfig = createNewConfig();
                newConfig.equipments = [];
                callback(newConfig, actionType);
            },
            removePackage(modelConfiguration, equipmentCode, callback) {
                let newConfig = createNewConfig();
                newConfig.packages = [];
                callback(newConfig, actionType);
            }
        };
    }

    const catalogClient = {
        getCatalog(brandId, modelCode, callback) {
            callback(catalog);
        }
    };

    const translator = aidaCore.TranslationService({});
    const dialogPublisher = aidaCore.DialogPublisher;
    let modelConfiguration;
    const whenConfigurationChanged = (newConfiguration) => {
        modelConfiguration = newConfiguration;
    };
    let configurator;
    let configurationClient;

    const selectedBrand = ko.observable('V');
    const loadedConfiguration = ko.observable();

    beforeEach(() => {
        configurationClient = createConfigurationClient();
        configurator = Configurator(
            {
                selectedBrand,
                whenConfigurationChanged,
                loadedConfiguration
            }, {
                translator,
                catalogClient,
                configurationClient,
                dialogPublisher
            });
        catalog.modelCompulsoryCombinationChoices = [];
        modelConfiguration = {};
        configurator.combinationOptions([]);
    });

    describe("when selecting a model", function () {
        it("load available equipments and packages for the model", function () {
            GivenASelectedModelFor(configurator);

            expect(configurator.availableEquipments().length).toBe(6);
            expect(_.filter(configurator.availableEquipments(), (item) => item.isPackage()).length).toBe(1);
            expect(_.filter(configurator.availableEquipments(), (item) => !item.isPackage()).length).toBe(5);
        });
    });

    describe('when selecting an equipment ', () => {
        it("call corresponding client", () => {
            GivenASelectedModelFor(configurator);
            spyOn(configurationClient, 'addEquipmentWithoutCombination');
            const bluetoohSelectable = SelectableItem(bluetooth, false);

            configurator.whenEquipmentSelected(bluetoohSelectable);

            expect(configurationClient.addEquipmentWithoutCombination).toHaveBeenCalled();
        });

        it("add the equipment to the configuration", () => {
            GivenASelectedModelFor(configurator);
            const bluetoohSelectable = SelectableItem(bluetooth, false);

            configurator.whenEquipmentSelected(bluetoohSelectable);

            expect(modelConfiguration.equipments[0].code).toBe(bluetooth.code);
        });

        it("call backend when an equipment is unselected", function () {
            GivenASelectedModelFor(configurator);
            spyOn(configurationClient, "removeEquipment");
            const bluetoohSelectable = SelectableItem(bluetooth, false);

            configurator.whenEquipmentSelected(bluetoohSelectable);
            configurator.whenEquipmentUnselected(bluetoohSelectable);

            expect(configurationClient.removeEquipment).toHaveBeenCalled();
        });

        it("remove the equipment from the configuration", () => {
            GivenASelectedModelFor(configurator);
            const bluetoohSelectable = SelectableItem(bluetooth, false);

            configurator.whenEquipmentSelected(bluetoohSelectable);
            configurator.whenEquipmentUnselected(bluetoohSelectable);

            expect(modelConfiguration.equipments).toEqual([]);
        });
    });

    describe('when an equipment has compulsories', () => {

        beforeEach(() => {
            CatalogHelper.camera.hasForcedCombinations = true;
            CatalogHelper.camera.compulsoryCombinations = [[navigationPack], [bluetooth]];
        });

        it("show selector when then equipment has more than one compulsory", () => {
            GivenASelectedModelFor(configurator);
            const cameraSelectable = SelectableItem(camera, false);

            configurator.whenEquipmentSelected(cameraSelectable);

            expect(configurator.combinationSelectorVisible()).toBe(true);
            expect(configurator.isCombinationMandatory()).toBe(false);
            expect(configurator.combinationOptions().length).toBe(2);
            expect(configurator.combinationOptions()[0].items.length).toBe(1);
            expect(configurator.combinationOptions()[0].items[0].code).toBe(navigationPack.code);
            expect(configurator.combinationOptions()[1].items.length).toBe(1);
            expect(configurator.combinationOptions()[1].items[0].code).toBe(bluetooth.code);
        });

        it("apply configuration after calling the backend for a compulsory option", () => {
            GivenASelectedModelFor(configurator);
            const cameraSelectable = SelectableItem(camera, false);
            configurator.whenEquipmentSelected(cameraSelectable);
            const chosenCombination = aCombination([bluetooth.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(modelConfiguration.equipments[0].combination[0].code).toEqual(bluetooth.code);
        });

        it("call to the server to add equipment", () => {
            GivenASelectedModelFor(configurator);
            spyOn(configurationClient, 'addEquipment');
            const cameraSelectable = SelectableItem(camera, false);
            configurator.whenEquipmentSelected(cameraSelectable);
            const chosenCombination = aCombination([bluetooth.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(configurationClient.addEquipment).toHaveBeenCalled();
        });
    });

    describe('when selecting a package', () => {
        it("call corresponding client", () => {
            GivenASelectedModelFor(configurator);
            spyOn(configurationClient, 'addPackageWithoutCombination');
            const safetyPackageSelectable = SelectableItem(safetyPackage, true);

            configurator.whenEquipmentSelected(safetyPackageSelectable);

            expect(configurationClient.addPackageWithoutCombination).toHaveBeenCalled();
        });

        it("add the package to the configuration", () => {
            GivenASelectedModelFor(configurator);
            const safetyPackageSelectable = SelectableItem(safetyPackage, true);

            configurator.whenEquipmentSelected(safetyPackageSelectable);

            expect(modelConfiguration.equipments[0].code).toBe(safetyPackage.code);
        });

        it("call backend when a package is unselected", function () {
            GivenASelectedModelFor(configurator);
            spyOn(configurationClient, "removePackage");
            const safetyPackageSelectable = SelectableItem(safetyPackage, true);

            configurator.whenEquipmentSelected(safetyPackageSelectable);
            configurator.whenEquipmentUnselected(safetyPackageSelectable);

            expect(configurationClient.removePackage).toHaveBeenCalled();
        });

        it("remove the package from the configuration", () => {
            GivenASelectedModelFor(configurator);
            const safetyPackageSelectable = SelectableItem(safetyPackage, true);

            configurator.whenEquipmentSelected(safetyPackageSelectable);
            configurator.whenEquipmentUnselected(safetyPackageSelectable);

            expect(modelConfiguration.equipments).toEqual([]);
        });
    });

    describe('when an package has compulsories', () => {

        beforeEach(() => {
            CatalogHelper.safetyPackage.hasForcedCombinations = true;
            CatalogHelper.safetyPackage.compulsoryCombinations = [[camera], [bluetooth]];
        });

        it("show selector when then package has more than one compulsory", () => {
            GivenASelectedModelFor(configurator);
            const safetyPackageSelectable = SelectableItem(safetyPackage, true);

            configurator.whenEquipmentSelected(safetyPackageSelectable);

            expect(configurator.combinationSelectorVisible()).toBe(true);
            expect(configurator.isCombinationMandatory()).toBe(false);
            expect(configurator.combinationOptions().length).toBe(2);
            expect(configurator.combinationOptions()[0].items.length).toBe(1);
            expect(configurator.combinationOptions()[0].items[0].code).toBe(camera.code);
            expect(configurator.combinationOptions()[1].items.length).toBe(1);
            expect(configurator.combinationOptions()[1].items[0].code).toBe(bluetooth.code);
        });

        it("apply configuration after calling the backend for a compulsory option", () => {
            GivenASelectedModelFor(configurator);
            const safetyPackageSelectable = SelectableItem(safetyPackage, true);
            configurator.whenEquipmentSelected(safetyPackageSelectable);
            const chosenCombination = aCombinationForAPackage([bluetooth.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(modelConfiguration.equipments[0].combination[0].code).toEqual(bluetooth.code);
        });

        it("call to the server to add equipment", () => {
            GivenASelectedModelFor(configurator);
            spyOn(configurationClient, 'addPackage');
            const safetyPackageSelectable = SelectableItem(safetyPackage, true);
            configurator.whenEquipmentSelected(safetyPackageSelectable);
            const chosenCombination = aCombinationForAPackage([bluetooth.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(configurationClient.addPackage).toHaveBeenCalled();
        });
    });

    function aCombinationForAPackage(items) {
        return aCombination(items, true);
    }

    function aCombination(items, isForPackage = false) {
        const root = {
            selected: ko.observable(false),
            isPackage() { return isForPackage; }
        };
        const combinationItems = _.map(items, (itemDescription) => {
            return {
                description: itemDescription,
                isInCatalog: () => true
            };
        });

        return Combination(root, combinationItems, {}, { error: () => { } }, translator);
    }

    function GivenASelectedModelFor(configurator) {
        configurator.whenModelSelected({
            key: { id: "123" },
            description: "VW Polo 1.2 Diesel"
        });
    }
});