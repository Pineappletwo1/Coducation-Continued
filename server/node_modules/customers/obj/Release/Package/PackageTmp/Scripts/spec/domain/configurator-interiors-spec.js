import Configurator from "../../src/domain/configurator/configurator";
import Combination from '../../src/domain/configurator/scripts/combination';
import CatalogHelper from './catalogHelper';

describe("configurator with interior should", () => {
    const emptyInterior = null;

    const catalog = CatalogHelper.catalog;
    const camera = CatalogHelper.camera;
    const bluetooth = CatalogHelper.bluetooth;
    const sky = CatalogHelper.sky;
    const blue = CatalogHelper.blue;
    const leather = CatalogHelper.leather;
    const corduroy = CatalogHelper.corduroy;

    let createConfigurationCall = {};
    let getCatalogCall = {};
    let changeInteriorWithoutCombinationCall = {};

    const actionType = {
        IsChangeInterior: () => { return true; }
    };

    const changeInteriorRequest = {};

    function createNewConfig() {
        return { color: null, interior: null, equipments: [], packages: [] };
    }

    function createConfigurationClient() {
        return {
            createConfiguration(model) {
                createConfigurationCall.model = model;
            },
            changeInteriorWithoutCombination(modelConfiguration, interiorCode, callback) {
                changeInteriorWithoutCombinationCall.modelConfiguration = modelConfiguration;
                changeInteriorWithoutCombinationCall.interiorCode = interiorCode;
                let newConfig = createNewConfig();
                newConfig.interior = { code: interiorCode };
                callback(newConfig, actionType);
            },
            changeInterior(configuration, combination, callback) {
                changeInteriorRequest.combination = combination;
                let newConfig = createNewConfig();
                newConfig.interior = { combination: _.map(combination.items, (item) => { return { code: item.description }; }) };
                callback(newConfig);
            },
            removeInterior(configuration, callback) {
                let newConfig = createNewConfig();
                newConfig.interior = null;
                callback(newConfig, actionType);
            }
        };
    }

    const catalogClient = {
        getCatalog(brandId, modelCode, callback) {
            getCatalogCall.modelCode = modelCode;
            callback(catalog);
        }
    };

    const translator = aidaCore.TranslationService({});
    const dialogPublisher = aidaCore.DialogPublisher;
    let modelConfiguration;
    const whenConfigurationChanged = (newConfiguration) => {
        modelConfiguration = newConfiguration;
    };
    let configurator;
    let configurationClient;

    const selectedBrand = ko.observable('V');
    const loadedConfiguration = ko.observable();

    beforeEach(() => {
        configurationClient = createConfigurationClient();
        configurator = Configurator(
            {
                selectedBrand,
                whenConfigurationChanged,
                loadedConfiguration
            }, {
                translator,
                catalogClient,
                configurationClient,
                dialogPublisher
            });
        catalog.modelCompulsoryCombinationChoices = [];
        modelConfiguration = {};
    });

    describe("when selecting an interior", function () {
        it("load available interiors when a model is selected", function () {
            GivenASelectedModelFor(configurator);

            expect(configurator.interiorOptions().length).toBe(3);
            expect(configurator.interiorOptions()[0].code).toBe(leather.code);
            expect(configurator.interiorOptions()[0].description).toBe("A1 - cuero");
        });

        it("load allowed colors for that interior", function () {
            GivenASelectedModelFor(configurator);

            configurator.selectedInterior(sky);

            expect(configurator.colorOptions().length).toBe(1);
            expect(configurator.colorOptions()[0].code).toBe(blue.code);
            expect(configurator.colorOptions()[0].description).toBe("X2X2 - blue");
        });

        it("call backend when a interior is selected", function () {
            changeInteriorWithoutCombinationCall = {};
            GivenASelectedModelFor(configurator);

            configurator.selectedInterior(leather);

            expect(changeInteriorWithoutCombinationCall.interiorCode).toBe(leather.code);
            expect(changeInteriorWithoutCombinationCall.modelConfiguration).not.toBe(null);
        });

        it("set the interior to the configuration", () => {
            modelConfiguration = undefined;
            GivenASelectedModelFor(configurator);

            configurator.selectedInterior(leather);

            expect(modelConfiguration.interior.code).toBe(leather.code);
        });

        it("call backend when a interior is unselected", function () {
            GivenASelectedModelFor(configurator);
            spyOn(configurationClient, "removeInterior");

            configurator.selectedInterior(emptyInterior);

            expect(configurationClient.removeInterior).toHaveBeenCalled();
        });

        it("not call backend when a interior is selected and the model is unselected", function () {
            spyOn(configurationClient, 'removeInterior');
            GivenASelectedModelFor(configurator);
            configurator.selectedInterior(leather);

            configurator.whenModelUnselected();

            expect(configurationClient.removeInterior).not.toHaveBeenCalled();
        });

        it("remove the interior to the configuration", () => {
            GivenASelectedModelFor(configurator);
            configurator.selectedInterior(leather);

            configurator.selectedInterior(emptyInterior);

            expect(modelConfiguration.interior).toEqual({});
        });
    });

    describe('when interior has compulsories', () => {

        beforeEach(() => {
            CatalogHelper.corduroy.hasForcedCombinations = true;
            CatalogHelper.corduroy.compulsoryCombinations = [[camera], [bluetooth]];
        });

        it("show selector when interior has compulsories combinations", () => {
            GivenASelectedModelFor(configurator);
            configurator.combinationOptions([]);

            configurator.selectedInterior(corduroy);

            expect(configurator.combinationSelectorVisible()).toBe(true);
            expect(configurator.isCombinationMandatory()).toBe(false);
            expect(configurator.combinationOptions().length).toBe(2);
            expect(configurator.combinationOptions()[0].items.length).toBe(1);
            expect(configurator.combinationOptions()[0].items[0].code).toBe("PR1");
            expect(configurator.combinationOptions()[1].items.length).toBe(1);
            expect(configurator.combinationOptions()[1].items[0].code).toBe("PR2");
        });

        it("call backend if a compulsory option is chosen", () => {
            GivenASelectedModelFor(configurator);
            configurator.selectedInterior(corduroy);
            const chosenCombination = aCombination([camera.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(changeInteriorRequest.combination).toEqual(chosenCombination);
        });

        it("apply configuration after calling the backend for a compulsory option", () => {
            GivenASelectedModelFor(configurator);
            configurator.selectedInterior(corduroy);
            const chosenCombination = aCombination([camera.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(modelConfiguration.interior.combination[0].code).toEqual(camera.code);
        });

        it("restore previous interior if backend fails", () => {
            configurationClient.changeInterior = (configuration, combination, callback, errorCallback) => {
                errorCallback();
            };
            GivenASelectedModelFor(configurator);
            configurator.selectedInterior(blue);
            configurator.selectedInterior(corduroy);
            const chosenCombination = aCombination([camera.code]);

            configurator.whenCombinationSelected(chosenCombination);

            expect(configurator.selectedInterior().code).toEqual(blue.code);
        });

        it("restore previous interior if no combination is selected", () => {
            GivenASelectedModelFor(configurator);
            configurator.selectedInterior(blue);
            configurator.selectedInterior(corduroy);

            configurator.whenCombinationSelected(undefined);

            expect(configurator.selectedInterior().code).toEqual(blue.code);
        });
    });

    function aCombination(items) {
        const root = { selected: ko.observable(false) };
        const combinationItems = _.map(items, (itemDescription) => {
            return {
                description: itemDescription,
                isInCatalog: () => true
            };
        });

        return Combination(root, combinationItems, {}, { error: () => { } }, translator);
    }

    function GivenASelectedModelFor(configurator) {
        configurator.whenModelSelected({
            key: { id: "123" },
            description: "VW Polo 1.2 Diesel"
        });
    }
});